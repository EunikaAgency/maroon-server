<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Editable Site Images Table</title>
  <!-- Bootstrap 5 CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    [contenteditable] {
      background-color: #fffbe6;
      min-height: 40px;
      padding: 8px;
    }
    
    .saving {
      opacity: 0.6;
    }
    
    .table-responsive {
      margin-top: 20px;
      max-height: 80vh;
      overflow-y: auto;
    }
    
    .img-thumbnail {
      max-width: 80px;
      height: auto;
      background: #f5f5f5;
    }
    
    .header-bg {
      background-color: #f8f9fa;
    }
    
    thead th {
      position: sticky;
      top: 0;
      background-color: #f8f9fa;
      z-index: 10;
      cursor: pointer;
    }
    
    .loading-row td {
      padding: 20px;
      text-align: center;
    }
    
    .sort-icon {
      margin-left: 5px;
    }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <div class="card shadow">
      <div class="card-header header-bg">
        <h2 class="h4 mb-0">Editable Image Metadata Table</h2>
      </div>
      <div class="card-body">
        <div class="table-responsive">
          <table class="table table-bordered table-hover" id="imagesTable">
            <thead class="table-light">
              <tr>
                <th>#</th>
                <th>Preview</th>
                <th>Title <span class="sort-icon">↓</span></th>
                <th>Alt Text</th>
                <th>Caption</th>
                <th>Description</th>
                <th>Image URL</th>
                <th>Used In</th>
                <th>Actions</th>
                <th>Delete</th>
              </tr>
            </thead>
            <tbody id="tableBody">
              <tr class="loading-row">
                <td colspan="10">
                  <div class="spinner-border" role="status">
                    <span class="visually-hidden">Loading...</span>
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <!-- Bootstrap 5 JS Bundle with Popper -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

  <script>
    const API_URL = 'https://revamped.retainingwallsupplies.com.au/wp-json/custom/products/get_all_site_images_data';
    const UPDATE_URL = 'https://revamped.retainingwallsupplies.com.au/wp-json/custom/products/update_image_metadata_callback';
    const DELETE_URL = 'https://revamped.retainingwallsupplies.com.au/wp-json/custom/products/delete_image_callback';
    
    // Batch processing variables
    const BATCH_SIZE = 30;
    let allImages = [];
    let displayedImages = [];
    let currentBatch = 0;
    let isLoading = false;
    let currentSort = { column: 'title', direction: 'asc' };
    
    // Cache DOM elements
    const tableBody = document.getElementById('tableBody');
    const tableContainer = document.querySelector('.table-responsive');
    const tableHeaders = document.querySelectorAll('thead th');
    
    // Intersection Observer for lazy loading
    const lazyImageObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const img = entry.target;
          img.src = img.dataset.src;
          lazyImageObserver.unobserve(img);
        }
      });
    }, { rootMargin: '100px' });
    
    async function loadImages() {
      try {
        const res = await fetch(API_URL);
        allImages = await res.json();
        displayedImages = [...allImages];
        tableBody.innerHTML = '';
        currentBatch = 0;
        sortImages(currentSort.column, currentSort.direction);
        loadNextBatch();
        
        // Set up infinite scroll
        tableContainer.addEventListener('scroll', handleScroll);
        
        // Set up sorting headers
        setupSortingHeaders();
      } catch (error) {
        console.error('Failed to fetch images:', error);
        tableBody.innerHTML = `<tr><td colspan="10" class="text-center text-danger">Failed to load images. Please try again later.</td></tr>`;
      }
    }
    
    function setupSortingHeaders() {
      tableHeaders.forEach((header, index) => {
        // Skip the #, Actions, and Delete columns (0, 8, 9)
        if (index === 0 || index === 8 || index === 9) return;
        
        header.addEventListener('click', () => {
          const column = getColumnName(index);
          let direction = 'asc';
          
          if (currentSort.column === column) {
            direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
          }
          
          // Update sort icons
          tableHeaders.forEach(h => {
            const icon = h.querySelector('.sort-icon');
            if (icon) icon.textContent = '';
          });
          
          const icon = header.querySelector('.sort-icon');
          if (icon) icon.textContent = direction === 'asc' ? '↓' : '↑';
          
          currentSort = { column, direction };
          sortImages(column, direction);
          
          // Reset and reload the table
          tableBody.innerHTML = '';
          currentBatch = 0;
          loadNextBatch();
        });
      });
    }
    
    function getColumnName(index) {
      const columns = [
        null, // #
        'preview', // Preview (won't be sorted)
        'title',
        'alt',
        'caption',
        'description',
        'url',
        'used_in'
      ];
      return columns[index];
    }
    
    function sortImages(column, direction) {
      displayedImages.sort((a, b) => {
        let valA = a[column];
        let valB = b[column];
        
        // Handle different data types
        if (column === 'used_in') {
          valA = valA ? valA.join(' ') : '';
          valB = valB ? valB.join(' ') : '';
        }
        
        // Handle empty values (empty strings come first)
        if (!valA && !valB) return 0;
        if (!valA) return direction === 'asc' ? -1 : 1;
        if (!valB) return direction === 'asc' ? 1 : -1;
        
        // Compare values
        valA = String(valA).toLowerCase();
        valB = String(valB).toLowerCase();
        
        if (valA < valB) return direction === 'asc' ? -1 : 1;
        if (valA > valB) return direction === 'asc' ? 1 : -1;
        return 0;
      });
    }
    
    function handleScroll() {
      const { scrollTop, scrollHeight, clientHeight } = tableContainer;
      if (scrollTop + clientHeight >= scrollHeight - 100 && !isLoading && currentBatch * BATCH_SIZE < displayedImages.length) {
        loadNextBatch();
      }
    }
    
    function loadNextBatch() {
      if (isLoading) return;
      
      isLoading = true;
      const fragment = document.createDocumentFragment();
      const start = currentBatch * BATCH_SIZE;
      const end = Math.min(start + BATCH_SIZE, displayedImages.length);
      
      // Use setTimeout to allow UI to update between batches
      setTimeout(() => {
        for (let i = start; i < end; i++) {
          const row = createRow(displayedImages[i], i);
          fragment.appendChild(row);
        }
        
        tableBody.appendChild(fragment);
        currentBatch++;
        isLoading = false;
        
        // If we've loaded all, remove scroll listener
        if (currentBatch * BATCH_SIZE >= displayedImages.length) {
          tableContainer.removeEventListener('scroll', handleScroll);
        }
      }, 50);
    }
    
    function createRow(image, index) {
      const row = document.createElement('tr');
      
      row.innerHTML = `
        <td>${index + 1}</td>
        <td>
          <img data-src="${image.url}" alt="${image.alt || ''}" class="img-thumbnail lazy-load">
        </td>
        <td contenteditable="true" data-field="title">${image.title || ''}</td>
        <td contenteditable="true" data-field="alt">${image.alt || ''}</td>
        <td contenteditable="true" data-field="caption">${image.caption || ''}</td>
        <td contenteditable="true" data-field="description">${image.description || ''}</td>
        <td>
          <div class="input-group">
            <input type="text" class="form-control form-control-sm" value="${image.url}" readonly>
            <button class="btn btn-outline-secondary btn-sm" onclick="copyToClipboard(this)">Copy</button>
          </div>
        </td>
        <td>
          ${(image.used_in && image.used_in.length > 0) 
            ? image.used_in.map(url => `<a href="${url}" target="_blank">${url}</a>`).join('<br>') 
            : '<em>Not used</em>'}
        </td>
        <td><button class="btn btn-primary btn-sm" onclick="saveRow(this, ${image.id})">Save</button></td>
        <td><button class="btn btn-danger btn-sm" onclick="deleteImage(${image.id}, this)">Delete</button></td>
      `;
      
      // Set up lazy loading for the image
      const img = row.querySelector('.lazy-load');
      lazyImageObserver.observe(img);
      
      return row;
    }
    
    async function saveRow(button, imageId) {
      const row = button.closest('tr');
      const fields = row.querySelectorAll('[contenteditable]');
      const data = { id: imageId };
    
      fields.forEach(cell => {
        const key = cell.getAttribute('data-field');
        data[key] = cell.textContent.trim();
      });
    
      button.disabled = true;
      button.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Saving...';
      row.classList.add('saving');
    
      try {
        const res = await fetch(UPDATE_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
    
        const result = await res.json();
        if (result.success) {
          button.innerHTML = '<i class="bi bi-check-circle"></i> Saved';
          button.classList.remove('btn-primary');
          button.classList.add('btn-success');
          
          // Update the data in our array
          const imageIndex = allImages.findIndex(img => img.id === imageId);
          if (imageIndex !== -1) {
            allImages[imageIndex] = { ...allImages[imageIndex], ...data };
          }
        } else {
          button.innerHTML = '<i class="bi bi-exclamation-triangle"></i> Error';
          button.classList.remove('btn-primary');
          button.classList.add('btn-danger');
          console.error('Save failed:', result);
        }
      } catch (error) {
        button.innerHTML = '<i class="bi bi-exclamation-triangle"></i> Error';
        button.classList.remove('btn-primary');
        button.classList.add('btn-danger');
        console.error('Network error:', error);
      }
    
      setTimeout(() => {
        button.disabled = false;
        button.innerHTML = 'Save';
        button.classList.remove('btn-success', 'btn-danger');
        button.classList.add('btn-primary');
        row.classList.remove('saving');
      }, 2000);
    }
    
    async function deleteImage(imageId, button) {
      if (!confirm("Are you sure you want to delete this image? This cannot be undone.")) return;
    
      button.disabled = true;
      button.innerText = 'Deleting...';
    
      try {
        const res = await fetch(DELETE_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id: imageId })
        });
    
        const result = await res.json();
        if (result.success) {
          const row = button.closest('tr');
          row.remove();
          
          // Remove from our arrays
          allImages = allImages.filter(img => img.id !== imageId);
          displayedImages = displayedImages.filter(img => img.id !== imageId);
        } else {
          alert('Failed to delete image.');
          console.error(result);
        }
      } catch (err) {
        console.error('Delete error:', err);
        alert('Network error while deleting image.');
      } finally {
        button.disabled = false;
        button.innerText = 'Delete';
      }
    }
    
    function copyToClipboard(button) {
      const input = button.previousElementSibling;
      input.select();
      input.setSelectionRange(0, 99999);
      document.execCommand('copy');
      button.innerText = 'Copied!';
      setTimeout(() => button.innerText = 'Copy', 1500);
    }
    
    // Load images when page loads
    document.addEventListener('DOMContentLoaded', loadImages);
  </script>
</body>
</html>